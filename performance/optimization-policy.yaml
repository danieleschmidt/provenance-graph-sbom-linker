# Performance Optimization Policy
# Automated performance monitoring and optimization for Go application

apiVersion: performance.io/v1
kind: OptimizationPolicy
metadata:
  name: provenance-performance-policy
  repository: "provenance-graph-sbom-linker"
  language: "go"
spec:
  # Performance targets and SLAs
  targets:
    latency:
      api:
        p50: "50ms"
        p95: "200ms" 
        p99: "500ms"
      
      graph_queries:
        simple: "100ms"
        complex: "2s"
        aggregation: "5s"
      
      sbom_processing:
        small: "1s"    # < 10MB
        medium: "10s"  # 10-100MB
        large: "60s"   # > 100MB
    
    throughput:
      api_requests: "1000 rps"
      graph_ingestion: "100 events/s"
      sbom_parsing: "10 files/s"
      
    resource_utilization:
      cpu: "70%"
      memory: "80%"
      disk_io: "60%"
      network: "50%"
    
    availability:
      uptime: "99.9%"
      error_rate: "< 0.1%"
      response_success: "> 99.8%"

  # Monitoring and alerting
  monitoring:
    # Go-specific metrics
    golang:
      gc_pause_target: "10ms"
      goroutine_leak_threshold: 10000
      memory_growth_rate: "5% per hour"
      cpu_profiling: "continuous"
      
      heap_metrics:
        max_heap_size: "2GB"
        gc_frequency_max: "every 30s"
        allocation_rate_max: "100MB/s"
    
    # Application metrics
    application:
      neo4j_query_time: "p95 < 1s"
      redis_cache_hit_rate: "> 95%"
      concurrent_connections: "< 10000"
      request_queue_depth: "< 100"
    
    # Infrastructure metrics
    infrastructure:
      container_cpu: "< 2 cores"
      container_memory: "< 4GB"
      pod_restart_rate: "< 1 per day"
      persistent_volume_usage: "< 80%"
    
    # Business metrics
    business:
      sbom_processing_success_rate: "> 99%"
      attestation_verification_time: "< 5s"
      compliance_report_generation: "< 30s"
      
  # Optimization strategies
  optimizations:
    # Go compiler optimizations
    build:
      flags:
        - "-ldflags=-s -w"          # Strip debug info
        - "-gcflags=-l=4"           # Aggressive inlining
        - "-buildmode=default"      # Standard build mode
      
      pgo_enabled: true             # Profile-guided optimization
      race_detector: false          # Disable in production
      
    # Runtime optimizations
    runtime:
      GOGC: 100                     # Standard GC target
      GOMEMLIMIT: "3GiB"           # Soft memory limit
      GOMAXPROCS: "0"              # Use all available CPUs
      
      experimental_features:
        - "rangefunc"               # Range over function types
        
    # Database optimizations
    database:
      neo4j:
        connection_pool: 50
        query_cache_size: "256MB"
        page_cache_size: "2GB"
        transaction_timeout: "30s"
        
        index_optimization:
          auto_create: true
          composite_indexes: true
          text_search_indexes: true
          
      redis:
        connection_pool: 100
        memory_policy: "allkeys-lru"
        max_memory: "1GB"
        persistence: "rdb"
    
    # Application-level optimizations
    application:
      # HTTP server tuning
      http:
        read_timeout: "30s"
        write_timeout: "30s"
        idle_timeout: "120s"
        max_header_bytes: "1MB"
        
      # Caching strategies
      caching:
        layers:
          - "redis"       # L1 cache
          - "memory"      # L2 cache
          - "database"    # L3 fallback
        
        policies:
          sbom_cache_ttl: "1h"
          provenance_cache_ttl: "24h"
          vulnerability_cache_ttl: "6h"
          
      # Concurrency management
      concurrency:
        worker_pools:
          sbom_processing: 10
          graph_updates: 5
          notifications: 3
        
        rate_limiting:
          api_requests: "100/minute/client"
          bulk_operations: "10/minute/client"
          admin_operations: "50/minute"

  # Performance testing
  testing:
    # Load testing scenarios
    load_tests:
      - name: "api_baseline"
        duration: "10m"
        users: 100
        ramp_up: "2m"
        endpoints:
          - "GET /api/v1/health"
          - "GET /api/v1/artifacts"
          - "POST /api/v1/provenance"
      
      - name: "graph_queries"
        duration: "5m"
        concurrent_queries: 50
        query_types:
          - "provenance_chain"
          - "vulnerability_impact"
          - "compliance_status"
      
      - name: "sbom_processing"
        duration: "15m"
        file_sizes: ["1MB", "10MB", "50MB"]
        concurrent_uploads: 20
        formats: ["cyclonedx", "spdx"]
    
    # Stress testing
    stress_tests:
      - name: "memory_pressure"
        duration: "30m"
        memory_target: "90%"
        gc_pressure: true
        
      - name: "cpu_saturation"
        duration: "15m"
        cpu_target: "95%"
        concurrent_operations: 1000
        
      - name: "database_stress"
        duration: "20m"
        connection_exhaustion: true
        large_result_sets: true
    
    # Benchmark targets
    benchmarks:
      functions:
        - "BenchmarkSBOMParsing"
        - "BenchmarkGraphTraversal"
        - "BenchmarkSignatureVerification"
        - "BenchmarkComplianceCheck"
      
      regression_threshold: "5%"
      performance_improvement_target: "10%"
      
  # Automation rules
  automation:
    # Auto-scaling
    scaling:
      horizontal:
        min_replicas: 2
        max_replicas: 20
        cpu_threshold: 70
        memory_threshold: 80
        custom_metrics:
          - "request_queue_depth > 50"
          - "response_time_p95 > 500ms"
      
      vertical:
        enabled: true
        cpu_request: "100m"
        cpu_limit: "2000m"
        memory_request: "256Mi"
        memory_limit: "4Gi"
    
    # Performance alerts
    alerting:
      rules:
        - name: "HighLatency"
          condition: "api_latency_p95 > 200ms for 5m"
          severity: "warning"
          actions: ["scale_up", "notify_team"]
        
        - name: "MemoryLeak"
          condition: "memory_usage growth > 10% per hour"
          severity: "critical"
          actions: ["restart_pod", "collect_heap_dump"]
        
        - name: "DatabaseSlow"
          condition: "neo4j_query_time_p95 > 2s for 3m"
          severity: "warning"
          actions: ["check_indexes", "analyze_queries"]
    
    # Auto-optimization
    optimization:
      # Profile-guided optimization
      pgo:
        enabled: true
        collection_interval: "24h"
        profile_duration: "10m"
        auto_rebuild: true
        
      # Query optimization
      database:
        index_analysis: "weekly"
        slow_query_detection: true
        auto_index_creation: false  # Require approval
        
      # Cache optimization
      caching:
        hit_rate_monitoring: true
        ttl_adjustment: "dynamic"
        eviction_policy_tuning: true

  # Reporting and visualization
  reporting:
    # Performance dashboards
    dashboards:
      grafana:
        panels:
          - "Application Performance Overview"
          - "Go Runtime Metrics"
          - "Database Performance"
          - "Cache Efficiency"
          - "Resource Utilization"
          
      custom:
        performance_report:
          frequency: "weekly"
          recipients: ["performance-team", "sre-team"]
          metrics:
            - "SLA compliance"
            - "Performance trends"
            - "Optimization opportunities"
    
    # Performance budgets
    budgets:
      api_response_time:
        budget: "200ms p95"
        current: "150ms p95"
        trend: "improving"
        
      memory_usage:
        budget: "4GB"
        current: "2.5GB"
        trend: "stable"
        
      cpu_utilization:
        budget: "70%"
        current: "45%"
        trend: "stable"

# Integration with existing tooling
integrations:
  # Monitoring stack
  observability:
    prometheus:
      custom_metrics: true
      recording_rules: true
      alerting_rules: true
      
    jaeger:
      trace_sampling: 0.1
      performance_analysis: true
      bottleneck_detection: true
      
    grafana:
      performance_dashboards: true
      SLA_tracking: true
      trend_analysis: true
  
  # CI/CD integration
  cicd:
    performance_gates:
      - "benchmark_regression < 5%"
      - "load_test_p95 < 200ms"
      - "memory_usage < 4GB"
      
    automated_testing:
      trigger: "on_pull_request"
      suite: "performance_regression"
      pass_threshold: 95